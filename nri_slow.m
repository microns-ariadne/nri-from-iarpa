function [nriNet, nriNeur, ROC] = nri_slow(C)%function [nriNet, nriNeur, ROC] = nri_slow(C)%% This is a very slow implementation, but is intended to be easy to read% and understand.%%% Computes the Neural Reconstruction Index (NRI). Given a count table of% matching synapses, C (matched by location and polarity), for a reference% (ground truth) and test (automated segmentation) graph, calculate NRI for% individual neurons (local scores) and the full network (global score).%% The (i+1)th row and (j+1)th column of C should contain the number of matching% synapses for the ith reference neuron/object and the jth test% neuron/object. The 1st row and 1st column are not-founds (deletions in% (i+1,1) and insertions in (1,j+1)). The (1,1) entry of C should always be% 0 since a synapse cannot be both deleted and inserted.%%% OUTPUTS% -------% nriNet:  A scalar value that is the global/network NRI score% nriNeur: A vector of NRI scores, one for each neuron. Values are ordered%          to match rows of the count table, C. The first value nriNeur(1)%          is set to NaN, since that row of C represents insertions, not a%          reference neuron.% ROC:     A structure containing TP, FP, and FN vectors of counts for each%          reference neuron, ordered in that same manner as nriNeur. These%          values can be used to compute precision and recall, which are%          often plotted against each other to form an ROC curve. Precision%          (P) and Recall (R) vectors are include in the structure as well.%%% Matt Roos% JHU/APL% 5/5/2016[I,J] = size(C);  % I-1 reference neurons, J-1 test neuronsROC.TP = zeros(I,1);ROC.FN = zeros(I,1);ROC.FP = zeros(I,1);% Loop over all the reference neurons (rows, excluding 1st row)...for iRef = 2:I   %fprintf('%d of %d\n',iRef,I);   % In comments below, cij is the (i,j)th element of C   % TP count for a neuron is sum of cij*(cij-1)/2 where i=iRef, summed   % over all j (all elements in a row excluding the first column, ci1)   ROC.TP(iRef) = sum(C(iRef,2:end).*(C(iRef,2:end)-1)/2);   % FN count includes [1] ci1*(ci1-1)/2 where ci1 is number of deleted   % synapses and [2] all possible products, cij*cik (where cij and cik are   % jth and kth elements of the iRef row), excluding k,j=1 (the deletion   % column) and j>=k (that is, we include cij*cik but not cik*cij and not   % cij*cij).   ROC.FN(iRef) = C(iRef,1)*(C(iRef,1)-1)/2;   for jTest = 1:J-1      for kTest = jTest+1:J         ROC.FN(iRef) = ROC.FN(iRef) + C(iRef,jTest)*C(iRef,kTest);      end   end   % FP count includes the sum of all possible products, cij*cpj, where   % i=iRef and the sum excludes term with p=i, or j=1.  The count also   % needs a value for i=iRef=1 (insertion row), which is outside of   % (after) this iRef loop.   for pRef = 1:I      for jTest = 2:J         if pRef~=iRef            ROC.FP(iRef) = ROC.FP(iRef) + C(iRef,jTest)*C(pRef,jTest);         end      end   end   ROC.FP(iRef) = ROC.FP(iRef)/2;end% A FP count is also needed for the insertion (1st) row, in order for the% sum of the neuron FPs to equal that of the true network FPiRef = 1;   % the insertion row, not really a reference neuronfor pRef = 1:I   for jTest = 2:J      if pRef~=iRef         ROC.FP(iRef) = ROC.FP(iRef) + C(iRef,jTest)*C(pRef,jTest);      end   endendROC.FP(iRef) = ROC.FP(iRef)/2;% Compute NRI for individual neuronsROC.P = ROC.TP./(ROC.TP+ROC.FP);ROC.R = ROC.TP./(ROC.TP+ROC.FN);nriNeur = 2*ROC.TP./(2*ROC.TP+ROC.FP+ROC.FN);% Compute NRI for full networkP = nansum(ROC.TP)/(nansum(ROC.TP)+nansum(ROC.FP));R = nansum(ROC.TP)/(nansum(ROC.TP)+nansum(ROC.FN));nriNet = 2*P*R/(P+R);end % nri_slow()%% SUBFUNCTIONS%-----------------------------function [I J] = itriu(sz, k)% function [I J] = itriu(sz) % OR% I = itriu(sz) OR% % Return the subindices [I J] (or linear indices I if single output call)% in the purpose of extracting an upper triangular part of the matrix of% the size SZ. Input k is optional shifting. For k=0, extract from the main% diagonal. For k>0 -> above the diagonal, k<0 -> below the diagonal%% This returnd same as [...] = find(triu(ones(sz),k))% - Output is a column and sorted with respect to linear indice% - No intermediate matrix is generated, that could be useful for large%   size problem% - Mathematically, A(itriu(size(A)) is called (upper) "half-vectorization"%   of A %% Example:%% A = [ 7     5     4%       4     2     3%       9     1     9%       3     5     7 ]%% I = itriu(size(A))  % gives [1 5 6 9 10 11]'% A(I)                % gives [7 5 2 4  3  9]' OR A(triu(A)>0)%% Author: Bruno Luong <brunoluong@yahoo.com>% Date: 21/March/2009if isscalar(sz)    sz = [sz sz];endm=sz(1);n=sz(2);% Main diagonal by defaultif nargin<2    k=0;endnc = n-max(k,0); % number of columns of the triangular partlo = ones(nc,1); % lower row indice for each columnhi = min((1:nc).'-min(k,0),m); % upper row indice for each columnif isempty(lo)    I = zeros(0,1);    J = zeros(0,1);else    c=cumsum([0; hi-lo]+1); % cumsum of the length    I = accumarray(c(1:end-1), (lo-[0; hi(1:end-1)]-1), ...                   [c(end)-1 1]);    I = cumsum(I+1); % row indice    J = accumarray(c,1);    J(1) = 1 + max(k,0); % The row indices starts from this value    J = cumsum(J(1:end-1)); % column indiceendif nargout<2    % convert to linear indices    I = sub2ind([m n], I, J);endend % itriu